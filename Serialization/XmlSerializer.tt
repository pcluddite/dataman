<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".Generated.cs" #>
//
//    DataMan - Supplemental library for managing data types and handling serialization
//    Copyright (C) 2021 Timothy Baxendale
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with this library; if not, write to the Free Software
//    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
//    USA
//
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Xml.Linq;
using Baxendale.Data.Collections;
using Baxendale.Data.Collections.Concurrent;
using Baxendale.Data.Reflection;

namespace Baxendale.Data.Xml
{
    public sealed partial class XmlSerializer
    {
<# BuildTypedMethods(generic: true); #>

<# BuildTypedMethods(generic: false); #>
    }
}
<#+
void BuildTypedMethods(bool generic)
{
    string typeOf, typeName, genericParam, typeParam, typeOfParam, typeDefine, createSerializerObject;
    if (generic)
    {
        typeName = "T";
        typeOf = "typeof(T)";
        genericParam = "<T>";

        typeParam = "";
        typeOfParam = "";
        typeDefine = "";
        createSerializerObject = $"CreateSerializerObject{genericParam}()";
    }
    else
    {
        typeName = "object";
        typeOf = "t";
        genericParam = "";

        typeDefine = $"Type {typeOf}";
        typeOfParam = $"{typeOf}, ";
        typeParam = $"{typeDefine}, ";
        createSerializerObject = $"CreateSerializerObject({typeOf})";
    }
#>
        public XElement Serialize<#= genericParam #>(<#= typeParam #><#= typeName #> obj)
        {
            XName contentName = GetSerializedTypeName(<#= typeOf #>);
            if (contentName == null)
                throw new UnregisteredTypeException(<#= typeOf #>);
            return Serialize(<#= typeOfParam #>obj, contentName);
        }

        public XElement Serialize<#= genericParam #>(<#= typeParam #><#= typeName #> obj, XName name)
        {
            if (name == null)
                throw new ArgumentNullException(nameof(name));
            return Serialize(<#= typeOfParam #>CreateSerializerObject(<#= typeOfParam #>obj), obj, name, ElementName);
        }

        internal XElement Serialize<#= genericParam #>(<#= typeParam #><#= typeName #> obj, XName defaultElementName, XName defaultAttributeName)
        {
            IXmlObjectSerializer<#= genericParam #> serializer = CreateSerializerObject(obj);
            XName contentName = GetSerializedTypeName(<#= typeOf #>);
            if (contentName == null)
                contentName = serializer.UsesXAttribute ? defaultAttributeName : defaultElementName;
            return Serialize(<#= typeOfParam #>serializer, obj, contentName, defaultElementName);
        }

        internal XElement Serialize<#= genericParam #>(<#= typeParam #>IXmlObjectSerializer<#= genericParam #> serializer, <#= typeName #> obj, XName contentName, XName defaultElementName)
        {
            XObject content;
            try
            {
                content = serializer.Serialize(obj, contentName);
            }
            catch (TargetInvocationException ex)
            {
                throw ex.GetBaseException();
            }
            if (serializer.UsesXAttribute)
            {
                XElement element = new XElement(defaultElementName ?? ElementName);
                element.Add(content);
                return element;
            }
            return (XElement)content;
        }

        internal IXmlObjectSerializer<#= genericParam #> CreateSerializerObject<#= genericParam #>(<#= typeParam#><#= typeName #> obj)
        {
            if (obj == null)
<#+ if (generic) { #>
                return new XmlNullSerializer<#= genericParam #>(this);
<#+ } else { #>
                return (IXmlObjectSerializer)Activator.CreateInstance(typeof(XmlNullSerializer<>).MakeGenericType(t), this);
<#+ } #>
            return <#= createSerializerObject #>;
        }

        internal IXmlObjectSerializer<#= genericParam #> CreateSerializerObject<#= genericParam #>(<#= typeDefine #>)
        { 
            LockingDictionary<Type, IXmlObjectSerializer> cache = _cache;
            Type serializerType = GetObjectSerializerType(<#= typeOf #>);
            if (serializerType == null)
                throw new UnsupportedTypeException(<#= typeOf #>);

            if (cache == null)
                return (IXmlObjectSerializer<#= genericParam #>)Activator.CreateInstance(serializerType, this);

            IXmlObjectSerializer serializer;
            if (!cache.TryGetValue(<#= typeOf #>, out serializer))
                cache.Add(<#= typeOf #>, serializer = (IXmlObjectSerializer)Activator.CreateInstance(serializerType, this));

            return (IXmlObjectSerializer<#= genericParam #>)serializer;
        }
<#+

    string[] xtypes = { "XElement", "XAttribute" };
    foreach (string xtype in xtypes)
    {
        string attributeCheck = (xtype == "XAttribute" ? "!" : "") + "serializer.UsesXAttribute";
#>

        public <#= typeName #> Deserialize<#= genericParam #>(<#= typeParam #><#= xtype #> content)
        {
            if (content == null) throw new ArgumentNullException(nameof(content));
            IXmlObjectSerializer<#= genericParam #> serializer = <#= createSerializerObject #>;
            if (<#= attributeCheck #>)
                throw new UnsupportedTypeException(<#= typeOf #>);
            try
            {
                return serializer.Deserialize(content);
            }
            catch (TargetInvocationException ex)
            {
                throw ex.GetBaseException();
            }
        }
<#+
    }
#>

        internal <#= typeName #> Deserialize<#= genericParam #>(<#= typeParam #>XElement content, XName defaultElementName, XName defaultAttributeName)
        {
            IXmlObjectSerializer<#= genericParam #> serializer = <#= createSerializerObject #>;
            XName contentName = GetSerializedTypeName(<#= typeOf #>);
            if (contentName == null)
                contentName = serializer.UsesXAttribute ? defaultAttributeName : defaultElementName;
            return Deserialize<#= genericParam #>(<#= typeOfParam#>serializer, content, contentName);
        }

        internal <#= typeName #> Deserialize<#= genericParam #>(<#= typeParam #>IXmlObjectSerializer<#= genericParam #> serializer, XElement content, XName contentName)
        {
            if (content == null) throw new ArgumentNullException(nameof(content));
            if (serializer.UsesXAttribute)
            {
                XAttribute attribute = content.Attribute(contentName ?? ValueAttributeName);
                if (attribute == null)
                    throw new XObjectNotFoundException(contentName.ToString());
                return serializer.Deserialize(attribute);
            }
            if (contentName != null)
                content = content.Element(contentName);
            return serializer.Deserialize(content);
        }
<#+
}
#>